{"version":3,"file":"index.min.js","sources":["node_modules/describe-type/source/is/array.js","node_modules/describe-type/source/is/arraylike.js","node_modules/object-chain/index.next.js","index.next.js"],"sourcesContent":["/**\n *\n * @function\n * @memberof is\n * @param {any} value\n * @returns {Boolean}\n */\nexport default function array(value) {\n\tif (value == null) return false;\n\treturn value.constructor === Array;\n}\n","import array from './array.js';\nimport string from './string.js';\n\n/**\n *\n * @function\n * @memberof is\n * @param {any} value\n * @returns {Boolean}\n */\nexport default function arraylike(value) {\n\treturn array(value) || string(value) || (\n\t\t(!!value && typeof value === 'object' && typeof value.length === 'number') &&\n\t\t(value.length === 0 || (value.length > 0 && (value.length - 1) in value))\n\t);\n}\n","import callable from 'describe-type/source/is/callable.js';\nimport apply from 'describe-type/source/@/apply.js';\n\nconst { setPrototypeOf, defineProperties, create, keys } = Object;\nconst arrayFrom = Array.from;\n\nconst processArgs = (args, initialValue) => (\n\tarrayFrom(args).reduce((acc, arg) => {\n\t\tacc[acc.length] = callable(arg) ? arg() : arg;\n\t\treturn acc;\n\t}, initialValue)\n);\n\nconst transform = (object, middleware) => {\n\tfunction chain() {\n\t\tlet last = '';\n\t\tconst pattern = this.object.reduce((acc, item) => {\n\t\t\tif (callable(object[item.name])) {\n\t\t\t\tconst args = processArgs(item.args, [acc, last]);\n\t\t\t\tacc = apply(object[item.name], this, args);\n\t\t\t\tlast = acc;\n\t\t\t} else {\n\t\t\t\tacc += object[item.name];\n\t\t\t\tlast = object[item.name];\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, last);\n\t\treturn middleware ? apply(middleware, this, [pattern, arguments], true) : pattern;\n\t}\n\n\tfunction connect(data) {\n\t\tfunction link() { return apply(chain, link, arguments); }\n\t\tlink.object = data;\n\t\tsetPrototypeOf(link, proto);\n\t\treturn link;\n\t}\n\n\tconst descriptors = keys(object).reduce((acc, name) => {\n\t\tconst isfn = callable(object[name]);\n\t\tacc[name] = {\n\t\t\t[isfn ? 'value' : 'get']: function connector() {\n\t\t\t\treturn connect(this.object.concat({ name, args: arguments }));\n\t\t\t},\n\t\t};\n\t\treturn acc;\n\t}, create(null));\n\n\tconst proto = defineProperties(function ObjectChain() {}, descriptors);\n\treturn defineProperties({ object }, keys(descriptors).reduce((acc, name) => {\n\t\tconst isfn = callable(object[name]);\n\t\tacc[name] = {\n\t\t\t[isfn ? 'value' : 'get']: function startup() {\n\t\t\t\treturn connect([{ name, args: arguments }]);\n\t\t\t},\n\t\t};\n\t\treturn acc;\n\t}, create(null)));\n};\n\nexport default transform;\n","import number from 'describe-type/source/is/number';\nimport string from 'describe-type/source/is/string';\nimport objectChain from 'object-chain';\n\nconst reEscapeRegExp = /[-[/\\]{}()*+?.,\\\\^$|#\\s]/g;\n\nconst escapeRegExp = (input) => {\n\tinput = string(input) ? input : '';\n\treEscapeRegExp.lastIndex = 0;\n\treturn input.replace(reEscapeRegExp, '\\\\$&');\n};\n\nconst src = (input) => {\n\tif (input === undefined) return 'undefined';\n\tif (input === null) return 'null';\n\tif (input.source) return src(input.source);\n\treturn input;\n};\n\nconst val = (input) => {\n\tinput = src(input);\n\treturn number(input) ? input : escapeRegExp(input);\n};\n\nconst compositions = {\n\tbeginningOfInput: '^',\n\tendOfInput: '$',\n\tanySingleCharExceptTheNewline: '.',\n\tanySingleChar: '[\\\\s\\\\S]',\n\tsomethingExceptTheNewline: '(?:.+)',\n\tsomething: '(?:[\\\\s\\\\S]+)',\n\tanythingExceptTheNewline: '(?:.*)',\n\tanything: '(?:[\\\\s\\\\S]*)',\n\tzeroOrMoreTimes: '*',\n\toneOrMoreTimes: '+',\n\tzeroOrOneTime: '?',\n\tor: '|',\n\tescape: '\\\\',\n\tbackslash: '\\\\',\n\tbackspace: '[\\\\b]',\n\twordBoundary: '\\\\b',\n\tnonWordBoundary: '\\\\B',\n\tdigit: '\\\\d',\n\tnonDigit: '\\\\D',\n\tformFeed: '\\\\f',\n\tlineFeed: '\\\\n',\n\tlineBreak: '\\\\r\\\\n?|\\\\n|\\\\u2028|\\\\u2029',\n\tcarriageReturn: '\\\\r',\n\twhiteSpace: '\\\\s',\n\tnotWhiteSpace: '\\\\S',\n\tnonASCIIwhitespace: '[\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]',\n\ttab: '\\\\t',\n\tverticalTab: '\\\\v',\n\talphanumeric: '\\\\w',\n\talphanumerical: '\\\\w',\n\tnonWord: '\\\\W',\n\tnul: '\\\\0',\n\tnil: '\\\\0',\n\tlowercase: '[a-z]',\n\tuppercase: '[A-Z]',\n\tletter: '[a-zA-Z]',\n\tnumeric: '[0-9]',\n\tvarchar: '[a-zA-Z_$][0-9a-zA-Z_$]',\n\teol: '(?:(?:\\\\n)|(?:\\\\r\\\\n))',\n\tstartCapture: '(',\n\tendCapture: ')',\n\tstartGroup: '(',\n\tendGroup: ')',\n\tstartCharset: '[',\n\tendCharset: ']',\n\tmodifier: (self, last, input) => `${self}(?${input})`,\n\tquote: (self, last, input) => `${self}${val(input)}`,\n\tvalue: (self, last, input) => `${self}${src(input)}`,\n\tplus: (self, last, input) => `${self}${src(input)}`,\n\tunicode: (self, last, input) => `${self}\\\\u${input}`,\n\tcontrol: (self, last, input) => `${self}\\\\c${input}`,\n\tnotRemember: (self, last, input) => `${self}(?:${src(input)})`,\n\tthen: (self, last, input) => `${self}(?:${src(input)})`,\n\tfind: (self, last, input) => `${self}(?:${src(input)})`,\n\tmaybe: (self, last, input) => `${self}(?:${src(input)})*`,\n\tmaybeOne: (self, last, input) => `${self}(?:${src(input)})?`,\n\tifFollowedBy: (self, last, input) => `${self}(?=${src(input)})`,\n\tifNotFollowedBy: (self, last, input) => `${self}(?!${src(input)})`,\n\tanythingBut: (self, last, input) => `${self}(?:[^${src(input)}]*)`,\n\tsomethingBut: (self, last, input) => `${self}(?:[^${src(input)}]+)`,\n\tnotCharset: (self, last, input) => `${self}[^${src(input)}]`,\n\tcharset: (self, last, input) => `${self}[${src(input)}]`,\n\tany: (self, last, input) => `${self}[${src(input)}]`,\n\tanyOf: (self, last, input) => `${self}[${src(input)}]`,\n\tgroup: (self, last, input) => `${self}(${src(input)})`,\n\tsize: (self, last, input) => `${self}{${0 | input}}`,\n\tatLeast: (self, last, input) => `${self}{${0 | input},}`,\n\tatMost: (self, last, input) => `${self}{,${0 | input}}`,\n\trange: (self, last, min, max) => `${self}{${0 | min},${0 | max}}`,\n\trepeat: (self, last, times) => `${self}${new Array((0 | times) + 1).join(last)}`,\n\treplace: (self, last, pattern, replacement) => self.replace(pattern, replacement),\n\tflags: (self, last, input) => new RegExp(self, input),\n\teither: (self, last, ...rest) => `${self}${rest.join('|')}`,\n};\n\nconst { assign } = Object;\nconst match = objectChain(compositions);\nconst rules = (custom, override, middleware) => {\n\tif (custom === undefined || custom === null) return match;\n\treturn objectChain(assign({}, custom, compositions, override), middleware);\n};\n\nexport { rules, match, src, val };\n"],"names":["array","escapeRegExp"],"mappings":";;;;;;;;;;;;;;;;oTAOe,CAAA,kDCIPA,CAAAA,s0CCoCwB,CAAA,obC1BAC,CAAAA"}