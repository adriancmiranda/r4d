{"version":3,"file":"index.min.js","sources":["node_modules/describe-type/source/is/array.js","node_modules/describe-type/source/is/arraylike.js","node_modules/object-chain/index.next.js","index.next.js"],"sourcesContent":["/**\n *\n * @function\n * @memberof is\n * @param {any} value\n * @returns {Boolean}\n */\nexport default function array(value) {\n\tif (value == null) return false;\n\treturn value.constructor === Array;\n}\n","import array from './array.js';\nimport string from './string.js';\n\n/**\n *\n * @function\n * @memberof is\n * @param {any} value\n * @returns {Boolean}\n */\nexport default function arraylike(value) {\n\treturn array(value) || string(value) || (\n\t\t(!!value && typeof value === 'object' && typeof value.length === 'number') &&\n\t\t(value.length === 0 || (value.length > 0 && (value.length - 1) in value))\n\t);\n}\n","import callable from 'describe-type/source/is/callable.js';\nimport string from 'describe-type/source/is/string.js';\nimport apply from 'describe-type/source/@/apply.js';\n\nconst { setPrototypeOf, defineProperties, create, keys } = Object;\nconst arrayFrom = Array.from;\n\nconst processArgs = (args, initialValue) => (\n\tarrayFrom(args).reduce((acc, arg) => {\n\t\tacc[acc.length] = callable(arg) ? arg() : arg;\n\t\treturn acc;\n\t}, initialValue)\n);\n\nconst transform = (object, middleware) => {\n\tfunction chain() {\n\t\tconst pattern = this.object.reduce((acc, item) => {\n\t\t\tif (callable(object[item.name])) {\n\t\t\t\tconst args = processArgs(item.args, [acc]);\n\t\t\t\tconst result = apply(object[item.name], this, args);\n\t\t\t\tif (string(result)) acc += result;\n\t\t\t\telse return result;\n\t\t\t} else {\n\t\t\t\tacc += object[item.name];\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, '');\n\t\treturn middleware ? apply(middleware, this, [pattern, arguments], true) : pattern;\n\t}\n\n\tfunction connect(data) {\n\t\tfunction link() { return apply(chain, link, arguments); }\n\t\tlink.object = data;\n\t\tsetPrototypeOf(link, proto);\n\t\treturn link;\n\t}\n\n\tconst descriptors = keys(object).reduce((acc, name) => {\n\t\tconst isfn = callable(object[name]);\n\t\tacc[name] = {\n\t\t\t[isfn ? 'value' : 'get']: function connector() {\n\t\t\t\treturn connect(this.object.concat({ name, args: arguments }));\n\t\t\t},\n\t\t};\n\t\treturn acc;\n\t}, create(null));\n\n\tconst proto = defineProperties(function ObjectChain() {}, descriptors);\n\treturn defineProperties({ object }, keys(descriptors).reduce((acc, name) => {\n\t\tconst isfn = callable(object[name]);\n\t\tacc[name] = {\n\t\t\t[isfn ? 'value' : 'get']: function startup() {\n\t\t\t\treturn connect([{ name, args: arguments }]);\n\t\t\t},\n\t\t};\n\t\treturn acc;\n\t}, create(null)));\n};\n\nexport default transform;\n","import objectChain from 'object-chain';\n\nconst reEscapeRegExp = /[-[\\]{}()*+?.,\\\\^$|#\\s]/g;\nconst escapeRegExp = (self, value) => {\n\tvalue = typeof value === 'string' || value instanceof String ? value : '';\n\treEscapeRegExp.lastIndex = 0;\n\treturn value.replace(reEscapeRegExp, '\\\\$&');\n};\n\nexport default objectChain({\n\tbeginningOfInput: '^',\n\tendOfInput: '$',\n\tanySingleCharExceptTheNewline: '.',\n\tzeroOrMoreTimes: '*',\n\toneOrMoreTimes: '+',\n\tzeroOrOneTime: '?',\n\tor: '|',\n\tescape: '\\\\',\n\tbackslash: '\\\\',\n\tbackspace: '\\\\b',\n\tnonWordBoundary: '\\\\B',\n\tdigit: '\\\\d',\n\tnonDigitChar: '\\\\D',\n\tformFeed: '\\\\f',\n\tlineFeed: '\\\\n',\n\tcarriageReturn: '\\\\r',\n\twhiteSpace: '\\\\s',\n\ttab: '\\\\t',\n\tverticalTab: '\\\\v',\n\talphanumeric: '\\\\w',\n\tnonWordChar: '\\\\W',\n\tnil: '\\\\0',\n\tupercaseVowel: '[AEIOU]',\n\tlowercaseVowel: '[aeiou]',\n\tuppercaseConsonant: '[B-DF-HJ-NP-TV-Z]',\n\tlowercaseConsonant: '[b-df-hj-np-tv-z]',\n\tlowercase: '[a-z]',\n\tuppercase: '[A-Z]',\n\tletter: '[a-zA-Z]',\n\tnumeric: '[0-9]',\n\tvarchar: '[$0-9A-Za-z_\\\\s]',\n\teol: '(?:(?:\\\\n)|(?:\\\\r\\\\n))',\n\tquote: escapeRegExp,\n\tvalue: (self, value) => value,\n\tcontrolChar: (self, value) => `\\\\c${value}`,\n\tnotRemember: (self, value) => `(?:${value})`,\n\tifFollowedBy: (self, value) => `(?=${value})`,\n\tifNotFollowedBy: (self, value) => `(?!${value})`,\n\tnotCharset: (self, value) => `[^${value}]`,\n\tcharset: (self, value) => `[${value}]`,\n\tsize: (self, value) => `{${0 | value}}`,\n\tatLeast: (self, value) => `{${0 | value},}`,\n\tatMost: (self, value) => `{,${0 | value}}`,\n\tgroup: (self, value) => `(${value})`,\n\trange: (self, min, max) => `{${0 | min},${0 | max}}`,\n\tflags: (self, value) => new RegExp(self, value),\n});\n"],"names":["array","objectChain"],"mappings":";;;;;;;;;;;;;;;;oTAOe,CAAA,kDCIPA,CAAAA,02CCoCwB,CAAA,sLCtCjBC,CAAAA"}