{"version":3,"file":"index.min.js","sources":["node_modules/describe-type/source/is/array.js","node_modules/describe-type/source/is/arraylike.js","node_modules/object-chain/index.next.js","node_modules/describe-type/source/is/regexp.js","rx.next.js","index.next.js"],"sourcesContent":["/**\n *\n * @function\n * @memberof is\n * @param {any} value\n * @returns {Boolean}\n */\nexport default function array(value) {\n\tif (value == null) return false;\n\treturn value.constructor === Array;\n}\n","import array from './array.js';\nimport string from './string.js';\n\n/**\n *\n * @function\n * @memberof is\n * @param {any} value\n * @returns {Boolean}\n */\nexport default function arraylike(value) {\n\treturn array(value) || string(value) || (\n\t\t(!!value && typeof value === 'object' && typeof value.length === 'number') &&\n\t\t(value.length === 0 || (value.length > 0 && (value.length - 1) in value))\n\t);\n}\n","import callable from 'describe-type/source/is/callable.js';\nimport apply from 'describe-type/source/@/apply.js';\n\nconst { setPrototypeOf, defineProperties, create, keys } = Object;\nconst arrayFrom = Array.from;\n\nconst processArgs = (args, initialValue) => (\n\tarrayFrom(args).reduce((acc, arg) => {\n\t\tacc[acc.length] = callable(arg) ? arg() : arg;\n\t\treturn acc;\n\t}, initialValue)\n);\n\nconst transform = (object, middleware) => {\n\tfunction chain() {\n\t\tlet last = '';\n\t\tconst pattern = this.object.reduce((acc, item) => {\n\t\t\tif (callable(object[item.name])) {\n\t\t\t\tconst args = processArgs(item.args, [acc, last]);\n\t\t\t\tacc = apply(object[item.name], this, args);\n\t\t\t\tlast = acc;\n\t\t\t} else {\n\t\t\t\tacc += object[item.name];\n\t\t\t\tlast = object[item.name];\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, last);\n\t\treturn middleware ? apply(middleware, this, [pattern, arguments], true) : pattern;\n\t}\n\n\tfunction connect(data) {\n\t\tfunction link() { return apply(chain, link, arguments); }\n\t\tlink.object = data;\n\t\tsetPrototypeOf(link, proto);\n\t\treturn link;\n\t}\n\n\tconst descriptors = keys(object).reduce((acc, name) => {\n\t\tconst isfn = callable(object[name]);\n\t\tacc[name] = {\n\t\t\t[isfn ? 'value' : 'get']: function connector() {\n\t\t\t\treturn connect(this.object.concat({ name, args: arguments }));\n\t\t\t},\n\t\t};\n\t\treturn acc;\n\t}, create(null));\n\n\tconst proto = defineProperties(function ObjectChain() {}, descriptors);\n\treturn defineProperties({ object }, keys(descriptors).reduce((acc, name) => {\n\t\tconst isfn = callable(object[name]);\n\t\tacc[name] = {\n\t\t\t[isfn ? 'value' : 'get']: function startup() {\n\t\t\t\treturn connect([{ name, args: arguments }]);\n\t\t\t},\n\t\t};\n\t\treturn acc;\n\t}, create(null)));\n};\n\nexport default transform;\n","/**\n *\n * @function\n * @memberof is\n * @param {any} value\n * @returns {Boolean}\n */\nexport default function regexp(value) {\n\tif (value == null) return false;\n\treturn value.constructor === RegExp;\n}\n","import string from 'describe-type/source/is/string';\nimport regexp from 'describe-type/source/is/regexp';\n\nconst RE_IDENTIFIER = /([a-zA-Z_$][0-9a-zA-Z_$]{0,50})/;\nconst RE_IDENTIFIER_REPLACE = new RegExp(`\\\\$\\\\+{${RE_IDENTIFIER.source}}`, 'g');\nconst RE_IDENTIFIER_BACKREFERENCE = new RegExp(`^[:?]&${RE_IDENTIFIER.source}`);\nconst RE_GROUP = new RegExp(`^[?:]<${RE_IDENTIFIER.source}>([^]*)`);\nconst RE_GROUP_B = /^\\?[:!=]/;\nconst RE_GROUPS = /([\\\\]?[()])/g;\nconst RE_EMPTY_GROUPS = /\\(\\)/g;\nconst { keys } = Object;\n\nfunction toObject(value) {\n\tconst object = { source: '', flags: '', groups: [] };\n\tif (regexp(value)) {\n\t\tobject.groups = value.source.split(RE_GROUPS);\n\t\tobject.source = value.source;\n\t\tobject.flags = value.flags;\n\t}\n\treturn object;\n}\n\nfunction attachGroup(object, chunk, index, groups) {\n}\n\nfunction detachGroup(object, chunk, index, groups) {\n}\n\nfunction createGroup(object, chunk, index, groups) {\n}\n\nfunction reduceGroups(object, chunk, index, groups) {\n\tswitch(chunk) {\n\t\tcase '(': attachGroup(object, chunk, index, groups);\n\t\tcase ')': detachGroup(object, chunk, index, groups);\n\t\tdefault: RE_GROUP_B.lastIndex = 0;\n\t\tif (groups[index - 1] === '(' && RE_GROUP_B.test(chunk) === false) {\n\t\t\tcreateGroup(object, chunk, index, groups);\n\t\t}\n\t}\n\treturn object.source;\n}\n\nfunction getGroupExtension(source, flags) {\n\tconst object = toObject(source, flags);\n\tobject.source = object.groups.reduce(reduceGroups, object);\n\treturn object;\n}\n\nexport default class Rx extends RegExp {\n\tconstructor(source, flags) {\n\t\tconst object = getGroupExtension(source, flags);\n\t\tsuper(object.source, object.flags);\n\t\tthis.groups = object.groups;\n\t}\n\n\texec(value) {\n\t\tconst object = super.exec(value);\n\t\tif (object) {\n\t\t\tobject.groups = {};\n\t\t\tkeys(this.groups).forEach((name) => {\n\t\t\t\tobject.groups[name] = object[this.groups[name]];\n\t\t\t}, this);\n\t\t}\n\t\treturn object;\n\t}\n\n\t[Symbol.replace](pattern, replacement) {\n\t\tconst ctx = this;\n\t\tif (string(replacement)) {\n\t\t\treplacement = replacement.replace(RE_IDENTIFIER_REPLACE, (m, name) => (\n\t\t\t\t`$${ctx.groups[name] || ''}`\n\t\t\t));\n\t\t}\n\t\treturn pattern.replace(ctx, replacement);\n\t}\n\n\t[Symbol.match](value) {\n\t\treturn this.exec(value);\n\t}\n}\n","import nil from 'describe-type/source/is/nil';\nimport undef from 'describe-type/source/is/undef';\nimport number from 'describe-type/source/is/number';\nimport string from 'describe-type/source/is/string';\nimport objectChain from 'object-chain';\nimport Rx from './rx.next';\n\nconst RE_ESCAPE_REGEXP = /[-[/\\]{}()*+?.,\\\\^$|#\\s]/g;\nconst RE_UNICODE_PREFIX = /^\\\\[xu]{1}/;\n\nconst escapeRegExp = (input) => {\n\tinput = string(input) ? input : '';\n\tRE_ESCAPE_REGEXP.lastIndex = 0;\n\treturn input.replace(RE_ESCAPE_REGEXP, '\\\\$&');\n};\n\nconst repeat = (input, count) => {\n\tcount = 0 | count;\n\treturn new Array(size < 0 ? 0 : size + 1).join(input);\n};\n\nconst pad = (input, width) => (\n\tinput.length < width ? repeat(input, width) : input\n);\n\nconst src = (input) => {\n\tif (undef(input)) return 'undefined';\n\tif (nil(input)) return 'null';\n\tif (input.source) return src(input.source);\n\treturn input;\n};\n\nconst val = (input) => {\n\tinput = src(input);\n\treturn number(input) ? input : escapeRegExp(input);\n};\n\nconst code = (input) => {\n\tinput = src(input);\n\tconst isstr = string(input);\n\tif (isstr && RE_UNICODE_PREFIX.test(input)) {\n\t\treturn input;\n\t} else if (isstr || number(input)) {\n\t\tconst hex = input.toString(16);\n\t\tif (hex.length < 3) return `\\\\x${pad(0, 2)}${hex}`;\n\t\treturn `\\\\u${pad(0, 4)}${hex}`;\n\t}\n\treturn isstr ? input : '';\n};\n\nconst compositions = {\n\tbeginningOfInput: '^',\n\tendOfInput: '$',\n\tanySingleCharExceptTheNewline: '.',\n\tanySingleChar: '[\\\\s\\\\S]',\n\tsomethingExceptTheNewline: '(?:.+)',\n\tsomething: '(?:[\\\\s\\\\S]+)',\n\tanythingExceptTheNewline: '(?:.*)',\n\tanything: '(?:[\\\\s\\\\S]*)',\n\tzeroOrMoreTimes: '*',\n\toneOrMoreTimes: '+',\n\tzeroOrOneTime: '?',\n\tor: '|',\n\tescape: '\\\\',\n\tbackslash: '\\\\',\n\tbackspace: '[\\\\b]',\n\twordBoundary: '\\\\b',\n\tnonWordBoundary: '\\\\B',\n\tdigit: '\\\\d',\n\tnonDigit: '\\\\D',\n\tformFeed: '\\\\f',\n\tlineFeed: '\\\\n',\n\tlineBreak: '\\\\r\\\\n?|\\\\n|\\\\u2028|\\\\u2029',\n\tcarriageReturn: '\\\\r',\n\twhiteSpace: '\\\\s',\n\tnotWhiteSpace: '\\\\S',\n\tnonASCIIWhiteSpace: '[\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]',\n\ttab: '\\\\t',\n\tverticalTab: '\\\\v',\n\talphanumeric: '\\\\w',\n\talphanumerical: '\\\\w',\n\tnonWord: '\\\\W',\n\tnul: '\\\\0',\n\tnil: '\\\\0',\n\tlowercase: '[a-z]',\n\tuppercase: '[A-Z]',\n\tletter: '[a-zA-Z]',\n\tnumeric: '[0-9]',\n\tvarchar: '[a-zA-Z_$][0-9a-zA-Z_$]',\n\teol: '(?:(?:\\\\n)|(?:\\\\r\\\\n))',\n\tstartCapture: '(',\n\tendCapture: ')',\n\tstartGroup: '(',\n\tendGroup: ')',\n\tstartCharset: '[',\n\tendCharset: ']',\n\tquote: (self, last, input) => `${self}${val(input)}`,\n\tvalue: (self, last, input) => `${self}${src(input)}`,\n\tplus: (self, last, input) => `${self}${src(input)}`,\n\tu: (self, last, input) => `${self}\\\\u${input}`,\n\tx: (self, last, input) => `${self}\\\\x${input}`,\n\tunicode: (self, last, input) => `${self}${code(input)}`,\n\tcontrol: (self, last, input) => `${self}\\\\c${input}`,\n\tnotRemember: (self, last, input) => `${self}(?:${src(input)})`,\n\tthen: (self, last, input) => `${self}(?:${src(input)})`,\n\tfind: (self, last, input) => `${self}(?:${src(input)})`,\n\tmaybe: (self, last, input) => `${self}(?:${src(input)})*`,\n\tmaybeOne: (self, last, input) => `${self}(?:${src(input)})?`,\n\tifFollowedBy: (self, last, input) => `${self}(?=${src(input)})`,\n\tifNotFollowedBy: (self, last, input) => `${self}(?!${src(input)})`,\n\tanythingBut: (self, last, input) => `${self}(?:[^${src(input)}]*)`,\n\tsomethingBut: (self, last, input) => `${self}(?:[^${src(input)}]+)`,\n\tnotCharset: (self, last, input) => `${self}[^${src(input)}]`,\n\tcharset: (self, last, input) => `${self}[${src(input)}]`,\n\tany: (self, last, input) => `${self}[${src(input)}]`,\n\tanyOf: (self, last, input) => `${self}[${src(input)}]`,\n\tgroup: (self, last, input) => `${self}(${src(input)})`,\n\tsize: (self, last, input) => `${self}{${0 | input}}`,\n\tatLeast: (self, last, input) => `${self}{${0 | input},}`,\n\tatMost: (self, last, input) => `${self}{,${0 | input}}`,\n\trange: (self, last, min, max) => `${self}{${0 | min},${0 | max}}`,\n\trepeat: (self, last, count) => `${self}${repeat(last, count)}`,\n\treplace: (self, last, pattern, replacement) => self.replace(pattern, replacement),\n\tflags: (self, last, input) => new Rx(self, input),\n\teither: (self, last, ...rest) => `${self}${rest.join('|')}`,\n};\n\nconst { assign } = Object;\nconst match = objectChain(compositions);\nconst rules = (custom, override, middleware) => {\n\tif (undef(custom) || nil(custom)) return match;\n\treturn objectChain(assign({}, custom, compositions, override), middleware);\n};\n\nexport { rules, match, src, val, code, pad, repeat };\n"],"names":["array","regexp","getGroupExtension","escapeRegExp"],"mappings":";;;;;;;;;;;;;;;;8aAOe,CAAA,kDCIPA,CAAAA,s0CCoCwB,CAAA,0WCxCjB,CAAA,mDCOVC,CAAAA,2NA6BL,CAAA,gEAQiBC,CAAAA,u1BCjBeC,CAAAA"}